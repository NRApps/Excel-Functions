(
    targetText as nullable text,
    SearchPhrase1 as list,
    ReturnPhrase1 as nullable list,
    SearchPhrase2 as nullable list,
    ReturnPhrase2 as nullable list,
    Conversion1 as list,
    Conversion2 as list,
    optional Threshold1 as nullable number,
    optional Threshold2 as nullable number,
    optional SearchDirection1 as nullable text,
    optional SearchDirection2 as nullable text
) as nullable record =>
let
    // ***************** Fuzzy Phrase Matching Block (fnFuzzyPhraseMatch) *****************
    fuzzyMatchResult = 
        if targetText = null then 
            null 
        else
            let
                // Normalize target text for fuzzy matching
                NormalizeText = (txt as text) as text => Text.Lower(Text.Trim(txt)),
                normTargetText = NormalizeText(targetText),
                normTargetLength = Text.Length(normTargetText),
                
                // Levenshtein distance function
                Levenshtein = (s as text, t as text) as number =>
                    let
                        sLen = Text.Length(s),
                        tLen = Text.Length(t),
                        sList = Text.ToList(s),
                        tList = Text.ToList(t),
                        initRow = List.Transform({0..tLen}, each _),
                        finalRow = List.Accumulate(
                            {1..sLen},
                            initRow,
                            (prevRow, i) =>
                                List.Accumulate(
                                    {1..tLen},
                                    {i},
                                    (row, j) =>
                                        let
                                            cost = if sList{i - 1} = tList{j - 1} then 0 else 1,
                                            deletion = row{j - 1} + 1,
                                            insertion = prevRow{j} + 1,
                                            substitution = prevRow{j - 1} + cost,
                                            minVal = List.Min({deletion, insertion, substitution})
                                        in
                                            row & {minVal}
                                )
                        )
                    in
                        finalRow{tLen},
                
                // Fuzzy match function (using normalized target)
                FuzzyMatch = (sourceText as text, searchList as list, optional returnList as nullable list, optional threshold as nullable number) as record =>
                    let
                        actualThreshold = if threshold <> null then threshold else 0.51,
                        zippedList =
                            if returnList <> null and List.Count(searchList) = List.Count(returnList) then
                                List.Transform(List.Zip({searchList, returnList}), each [SearchPhraseOriginal = _{0}, ReturnedPhrase = _{1}])
                            else
                                List.Transform(searchList, each [SearchPhraseOriginal = _, ReturnedPhrase = _]),
                        normText = normTargetText,
                        textLength = normTargetLength,
                        slidingPhrases = (searchPhrase as text) as list =>
                            let
                                sLen = Text.Length(searchPhrase),
                                rangePositions = {0..(textLength - sLen)},
                                windows = List.Transform(rangePositions, (i) => [
                                    before = if i = 0 then null else Text.Middle(normText, i - 1, 1),
                                    match = Text.Middle(normText, i, sLen),
                                    after = if i + sLen >= textLength then null else Text.Middle(normText, i + sLen, 1)
                                ]),
                                isLetter = (c as nullable text) as logical =>
                                    if c = null then false else List.Contains({"a".."z", "A".."Z"}, c),
                                boundaryWindows = List.Select(windows, each
                                    let
                                        b = _[before],
                                        a = _[after],
                                        startOkay = b = null or not isLetter(b),
                                        endOkay = a = null or not isLetter(a)
                                    in
                                        startOkay and endOkay
                                )
                            in
                                List.Transform(boundaryWindows, each _[match]),
                        TestPhrase = (searchPhrase as text) as record =>
                            let
                                possiblePhrases = slidingPhrases(searchPhrase),
                                scored = List.Transform(possiblePhrases, (phrase) =>
                                    let
                                        dist = Levenshtein(phrase, searchPhrase),
                                        maxLen = List.Max({Text.Length(phrase), Text.Length(searchPhrase)}),
                                        similarity = if maxLen = 0 then 1 else 1 - (dist / maxLen)
                                    in
                                        [SearchedPhrase = searchPhrase, MatchedPhrase = phrase, Similarity = similarity]
                                ),
                                good = List.Select(scored, each _[Similarity] >= actualThreshold),
                                best = if List.Count(good) = 0 then
                                            [SearchedPhrase = null, MatchedPhrase = null, Similarity = null]
                                       else
                                            let
                                                maxSim = List.Max(List.Transform(good, each _[Similarity])),
                                                top = List.First(List.Select(good, each _[Similarity] = maxSim))
                                            in
                                                top
                            in
                                best,
                        AllMatches = List.Transform(zippedList, (rec) =>
                            let
                                origPhrase = rec[SearchPhraseOriginal],
                                normalizedPhrase = NormalizeText(origPhrase),
                                combinedPhrase = Text.Replace(normalizedPhrase, " ", ""),
                                baseResult = TestPhrase(normalizedPhrase),
                                combinedResult = TestPhrase(combinedPhrase),
                                FinalBest =
                                    if baseResult[Similarity] = null and combinedResult[Similarity] = null then
                                        [SearchedPhrase = null, MatchedPhrase = null, ReturnedPhrase = rec[ReturnedPhrase], Similarity = null]
                                    else if baseResult[Similarity] = null then
                                        [SearchedPhrase = normalizedPhrase, MatchedPhrase = combinedResult[MatchedPhrase], ReturnedPhrase = rec[ReturnedPhrase], Similarity = combinedResult[Similarity]]
                                    else if combinedResult[Similarity] = null then
                                        [SearchedPhrase = normalizedPhrase, MatchedPhrase = baseResult[MatchedPhrase], ReturnedPhrase = rec[ReturnedPhrase], Similarity = baseResult[Similarity]]
                                    else if baseResult[Similarity] >= combinedResult[Similarity] then
                                        [SearchedPhrase = normalizedPhrase, MatchedPhrase = baseResult[MatchedPhrase], ReturnedPhrase = rec[ReturnedPhrase], Similarity = baseResult[Similarity]]
                                    else
                                        [SearchedPhrase = normalizedPhrase, MatchedPhrase = combinedResult[MatchedPhrase], ReturnedPhrase = rec[ReturnedPhrase], Similarity = combinedResult[Similarity]]
                            in
                                FinalBest
                        ),
                        ValidMatches = List.Select(AllMatches, each _[Similarity] <> null),
                        FinalBest = if List.Count(ValidMatches) = 0 then
                                        [SearchedPhrase = null, MatchedPhrase = null, ReturnedPhrase = null, Similarity = null]
                                    else
                                        let
                                            topScore = List.Max(List.Transform(ValidMatches, each _[Similarity])),
                                            topMatch = List.First(List.Select(ValidMatches, each _[Similarity] = topScore))
                                        in
                                            topMatch
                    in
                        FinalBest,
                // Get fuzzy match results for both search phrases
                match1 = FuzzyMatch(targetText, SearchPhrase1, ReturnPhrase1, Threshold1),
                match2 = if SearchPhrase2 <> null then FuzzyMatch(targetText, SearchPhrase2, ReturnPhrase2, Threshold2)
                         else [SearchedPhrase = null, MatchedPhrase = null, ReturnedPhrase = null, Similarity = null],
                finalFuzzyResult = [
                    SearchedPhrase1 = match1[SearchedPhrase],
                    MatchedPhrase1 = match1[MatchedPhrase],
                    ReturnedPhrase1 = match1[ReturnedPhrase],
                    Similarity1 = match1[Similarity],
                    SearchedPhrase2 = match2[SearchedPhrase],
                    MatchedPhrase2 = match2[MatchedPhrase],
                    ReturnedPhrase2 = match2[ReturnedPhrase],
                    Similarity2 = match2[Similarity]
                ]
            in
                finalFuzzyResult,

    // ***************** Fuzzy Extraction Block (fnFuzzyExtract) *****************
    fuzzyExtractResult =
        if targetText = null then
            null
        else
            let
                // Cleaning Block: Remove unwanted characters from targetText.
                UnwantedChars = { Character.FromNumber(160) },
                CleanTargetText = Text.Remove(targetText, UnwantedChars),
                
                // Define default search directions if not provided
                direction1 = if SearchDirection1 <> null then Text.Trim(SearchDirection1) else "left",
                direction2 = if SearchDirection2 <> null then Text.Trim(SearchDirection2) else "left",
                
                // Helper: Extract the first number using a regex.
                GetNumericPortion = (txt as text) as nullable text =>
                    let
                        numMatch = try RegexMatch(txt, "^[+-]?\d+(?:[.,]\d+)?(?:\s*(?:[eE][-+]?\d+|[×x*]\s*10\^?[-+]?\d+))?") otherwise null,
                        numText = if numMatch <> null and List.Count(numMatch) > 0 then numMatch{0} else ""
                    in
                        Text.Trim(numText),
                
                // Helper: If the text contains a range then return it as "number1-number2".
                GetRangeFromExtractedText = (extractedText as text) as nullable text =>
                    let
                        Cleaned = Text.Trim(extractedText),
                        pattern = "([+-]?\d+(?:[.,]\d+)?(?:\s*(?:[eE][-+]?\d+|[×x*]\s*10\^?[-+]?\d+))?)[\s]*[-–—][\s]*([+-]?\d+(?:[.,]\d+)?(?:\s*(?:[eE][-+]?\d+|[×x*]\s*10\^?[-+]?\d+))?)",
                        match = try RegexMatch(Cleaned, pattern, "i") otherwise null
                    in
                        if match <> null and List.Count(match) > 2 then match{1} & "-" & match{2} else null,
                
                // Helper: Normalize a number that may be expressed in scientific notation.
                NormalizeFinalNumber = (valueText as nullable text) as nullable number =>
                    let
                        raw = if valueText = null then null else Text.Trim(valueText),
                        rawNoCaret = if raw <> null then Text.Replace(raw, "^", "") else raw,
                        parts =
                            if rawNoCaret <> null and Text.Contains(rawNoCaret, "10") and List.AnyTrue({Text.Contains(rawNoCaret, "×"), Text.Contains(rawNoCaret, "x"), Text.Contains(rawNoCaret, "*")})
                            then
                                let
                                    separators = {"×", "*", "x"},
                                    found = List.First(List.Select(separators, each Text.Contains(rawNoCaret, _)), null),
                                    split1 = if found <> null then Text.Split(rawNoCaret, found) else {rawNoCaret},
                                    mainPart = if List.Count(split1) = 2 then Text.Trim(split1{0}) else rawNoCaret,
                                    split2Raw = if List.Count(split1) = 2 then Text.Trim(split1{1}) else "",
                                    split2Clean = Text.Replace(split2Raw, "^", ""),
                                    split2 = Text.Split(split2Clean, "10"),
                                    exponent = if List.Count(split2) = 2 then Text.Trim(split2{1}) else null,
                                    recombined = if exponent <> null then mainPart & "e" & exponent else rawNoCaret
                                in
                                    recombined
                            else
                                rawNoCaret,
                        sciCleaned = Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Replace(parts, "×", "e"), "x10^", "e"), "*10^", "e"), "*10", "e"), " x10", "e"),
                        cleaned = if Text.Contains(sciCleaned, ",") and not Text.Contains(sciCleaned, ".")
                                  then Text.Replace(Text.Remove(sciCleaned, {" "}), ",", ".")
                                  else Text.Replace(Text.Remove(sciCleaned, {" "}), ",", ""),
                        asNumber = try Number.FromText(cleaned) otherwise null
                    in
                        asNumber,
                
                // Helper: Determines if the extracted text contains scientific notation.
                IsScientificText = (txt as text) as logical =>
                    let
                        CleanText = Text.Trim(txt),
                        Indicators = {"e-", "e+", "×10-", "× 10-", "*10-", "* 10-", "x10-", "x 10-", " x10-", " x10-", "^10-", "^ 10-"}
                    in
                        List.AnyTrue(List.Transform(Indicators, each Text.Contains(CleanText, _))),
                
                // Helper: Build a dynamic regex that extracts a number (or range) immediately
                // to the left or right of the provided unit based on the search direction.
                ExtractFullTextFromSource = (source as text, phrase as nullable text, optional direction as text) as nullable record =>
                    let
                        Cleaned = Text.Trim(Text.Replace(Text.Replace(source, "#(lf)", " "), ",", "")),
                        p = if phrase = null then null else Text.Trim(phrase),
                        baseNumberPattern = "[+-]?\d+(?:\.\d+)?(?:\s*(?:[eE][-+]?\d+|[×x*]\s*10\^?[-+]?\d+))?",
                        rangePattern = "(" & baseNumberPattern & ")(?:\s*(?:[-–—]|±)\s*(" & baseNumberPattern & "))?",
                        actualDirection = if direction <> null then Text.Lower(Text.Trim(direction)) else "left",
                        pattern = 
                            if actualDirection = "left" then
                                rangePattern & "[ \t]*(\[)?" & p
                            else if actualDirection = "right" then
                                p & "[ \t]*(\[)?" & rangePattern
                            else
                                rangePattern & "[ \t]*(\[)?" & p,
                        match = try RegexMatch(Cleaned, pattern, "i") otherwise null,
                        fullText = if match <> null and List.Count(match) > 0 then match{0} else null,
                        TrimTrailingCharacters = (s as text, unwanted as list) as text =>
                            if s = "" then ""
                            else if List.Contains(unwanted, Text.End(s, 1)) then @TrimTrailingCharacters(Text.Start(s, Text.Length(s)-1), unwanted) else s,
                        cleanedFullText = if fullText <> null then TrimTrailingCharacters(fullText, {"*", "]", ")", "."}) else null
                    in
                        [ExtractedText = cleanedFullText, RegexPattern = pattern],
                
                // Helper: Derive the numeric value (and its range) from the full extracted text.
                DeriveValueAndRange = (fullText as text) as record =>
                    let
                        hasPlusMinus = Text.Contains(fullText, "±"),
                        provisional =
                            if hasPlusMinus then
                                let
                                    mainValText = GetNumericPortion(Text.Trim(Text.BeforeDelimiter(fullText, "±"))),
                                    uncertaintyText = GetNumericPortion(Text.Trim(Text.AfterDelimiter(fullText, "±"))),
                                    mainVal = NormalizeFinalNumber(mainValText),
                                    uncertaintyVal = NormalizeFinalNumber(uncertaintyText),
                                    rangeText = if mainVal <> null and uncertaintyVal <> null then Number.ToText(mainVal - uncertaintyVal) & "-" & Number.ToText(mainVal + uncertaintyVal) else null,
                                    extractedValue = if mainVal <> null then Text.From(mainVal) else null
                                in
                                    [ ExtractedValue = extractedValue, ExtractedRange = rangeText, ExtractedNumber = mainVal ]
                            else
                                let
                                    valText = GetNumericPortion(fullText),
                                    mainVal = NormalizeFinalNumber(valText),
                                    rangeText = GetRangeFromExtractedText(fullText)
                                in
                                    [ ExtractedValue = valText, ExtractedRange = rangeText, ExtractedNumber = mainVal ],
                        finalRange = if IsScientificText(fullText) then null else provisional[ExtractedRange]
                    in
                        [ ExtractedValue = provisional[ExtractedValue],
                          ExtractedRange = finalRange,
                          ExtractedNumber = provisional[ExtractedNumber] ],
                
                // Extraction Block for a single set.
                ExtractValueBlock = (source as text, matched as nullable text, direction as text) as record =>
                    if matched = null then
                        [ ExtractedText = null, RegexUsed = null, ExtractedValue = null, IsScientific = null, ExtractedRange = null, ExtractedNumber = null ]
                    else
                        let
                            fullTextRecord = ExtractFullTextFromSource(source, matched, direction),
                            fullText = fullTextRecord[ExtractedText],
                            regexUsed = fullTextRecord[RegexPattern],
                            valueAndRange = if fullText <> null then DeriveValueAndRange(fullText) else [ ExtractedValue = null, ExtractedRange = null, ExtractedNumber = null ],
                            newValue = valueAndRange[ExtractedValue],
                            num = valueAndRange[ExtractedNumber],
                            rangeText = valueAndRange[ExtractedRange],
                            isSci = if num <> null then IsScientificText(fullText) else false
                        in
                            if num = null then
                                [ ExtractedText = fullText, RegexUsed = regexUsed, ExtractedValue = newValue, IsScientific = isSci, ExtractedRange = rangeText, ExtractedNumber = num ]
                            else
                                [ ExtractedText = fullText, RegexUsed = regexUsed, ExtractedValue = newValue, IsScientific = isSci, ExtractedRange = rangeText, ExtractedNumber = num ],
                
                ValueBlock1 = ExtractValueBlock(CleanTargetText, fuzzyMatchResult[MatchedPhrase1], direction1),
                ValueBlock2 = if fuzzyMatchResult[MatchedPhrase2] = null then
                                [ ExtractedText = null, RegexUsed = null, ExtractedValue = null, IsScientific = null, ExtractedRange = null, ExtractedNumber = null ]
                              else
                                ExtractValueBlock(CleanTargetText, fuzzyMatchResult[MatchedPhrase2], direction2),
                fuzzyExtractResult = [
                    ExtractedText1 = ValueBlock1[ExtractedText],
                    RegexUsed1 = ValueBlock1[RegexUsed],
                    ExtractedValue1 = ValueBlock1[ExtractedValue],
                    IsScientific1 = ValueBlock1[IsScientific],
                    ExtractedRange1 = ValueBlock1[ExtractedRange],
                    ExtractedNumber1 = ValueBlock1[ExtractedNumber],
                    ExtractedText2 = ValueBlock2[ExtractedText],
                    RegexUsed2 = ValueBlock2[RegexUsed],
                    ExtractedValue2 = ValueBlock2[ExtractedValue],
                    IsScientific2 = ValueBlock2[IsScientific],
                    ExtractedRange2 = ValueBlock2[ExtractedRange],
                    ExtractedNumber2 = ValueBlock2[ExtractedNumber]
                ]
            in
                fuzzyExtractResult,
    
    // ***************** Conversion Block (fnConvertValue) *****************
    convertResult = 
        let
            // Conversion Set 1:
            idx1 = if fuzzyMatchResult[ReturnedPhrase1] <> null then List.PositionOf(ReturnPhrase1, fuzzyMatchResult[ReturnedPhrase1]) else -1,
            ConversionUsed1 = if idx1 >= 0 then Conversion1{idx1} else null,
            NumericConversion1 = if Value.Is(ConversionUsed1, type number) then ConversionUsed1 else try Number.FromText(Text.From(ConversionUsed1)) otherwise null,
            ConversionNumber1 =
                if fuzzyExtractResult[ExtractedNumber1] = null or ConversionUsed1 = null then
                    null
                else if NumericConversion1 <> null then
                    fuzzyExtractResult[ExtractedNumber1] * NumericConversion1
                else if Value.Is(ConversionUsed1, type text) then
                    try Expression.Evaluate(
                        Text.Replace(ConversionUsed1, "x", Number.ToText(fuzzyExtractResult[ExtractedNumber1])),
                        [ x = fuzzyExtractResult[ExtractedNumber1] ]
                    ) otherwise null
                else
                    null,
            // Conversion Set 2:
            idx2 = if fuzzyMatchResult[ReturnedPhrase2] <> null then List.PositionOf(ReturnPhrase2, fuzzyMatchResult[ReturnedPhrase2]) else -1,
            ConversionUsed2 = if idx2 >= 0 then Conversion2{idx2} else null,
            NumericConversion2 = if Value.Is(ConversionUsed2, type number) then ConversionUsed2 else try Number.FromText(Text.From(ConversionUsed2)) otherwise null,
            ConversionNumber2 =
                if fuzzyExtractResult[ExtractedNumber2] = null or ConversionUsed2 = null then
                    null
                else if NumericConversion2 <> null then
                    fuzzyExtractResult[ExtractedNumber2] * NumericConversion2
                else if Value.Is(ConversionUsed2, type text) then
                    try Expression.Evaluate(
                        Text.Replace(ConversionUsed2, "x", Number.ToText(fuzzyExtractResult[ExtractedNumber2])),
                        [ x = fuzzyExtractResult[ExtractedNumber2] ]
                    ) otherwise null
                else
                    null,
            finalConvertResult = [
                ConversionUsed1 = ConversionUsed1,
                ConversionNumber1 = ConversionNumber1,
                ConversionUsed2 = ConversionUsed2,
                ConversionNumber2 = ConversionNumber2
            ]
        in
            finalConvertResult,
    
    // ***************** Combine All Results *****************
    finalResult = [
        SearchedPhrase1 = fuzzyMatchResult[SearchedPhrase1],
        MatchedPhrase1 = fuzzyMatchResult[MatchedPhrase1],
        ReturnedPhrase1 = fuzzyMatchResult[ReturnedPhrase1],
        Similarity1 = fuzzyMatchResult[Similarity1],
        SearchedPhrase2 = fuzzyMatchResult[SearchedPhrase2],
        MatchedPhrase2 = fuzzyMatchResult[MatchedPhrase2],
        ReturnedPhrase2 = fuzzyMatchResult[ReturnedPhrase2],
        Similarity2 = fuzzyMatchResult[Similarity2],
        ExtractedText1 = fuzzyExtractResult[ExtractedText1],
        RegexUsed1 = fuzzyExtractResult[RegexUsed1],
        ExtractedValue1 = fuzzyExtractResult[ExtractedValue1],
        IsScientific1 = fuzzyExtractResult[IsScientific1],
        ExtractedNumber1 = fuzzyExtractResult[ExtractedNumber1],
        ExtractedText2 = fuzzyExtractResult[ExtractedText2],
        RegexUsed2 = fuzzyExtractResult[RegexUsed2],
        ExtractedValue2 = fuzzyExtractResult[ExtractedValue2],
        IsScientific2 = fuzzyExtractResult[IsScientific2],
        ExtractedNumber2 = fuzzyExtractResult[ExtractedNumber2],
        ConversionUsed1 = convertResult[ConversionUsed1],
        ConversionNumber1 = convertResult[ConversionNumber1],
        ConversionUsed2 = convertResult[ConversionUsed2],
        ConversionNumber2 = convertResult[ConversionNumber2]
    ]
in
    finalResult
